#!/usr/bin/env node

/**
 * Merge Vitest (V8) LCOV with Cypress (Istanbul/NYC) coverage into a single LCOV report for Sonar.
 *
 * Expected inputs:
 *  - Vitest LCOV:   coverage/lcov.info
 *  - Cypress NYC:   .nyc_output/** (generated by @cypress/code-coverage)
 *
 * Output:
 *  - Final merged LCOV: coverage/lcov.info (overwritten)
 *
 * Notes:
 *  - This script runs NYC to generate Cypress LCOV, then concatenates + de-duplicates SF blocks.
 *  - Paths are normalized to forward slashes for Sonar compatibility.
 */

import {existsSync, mkdirSync, readFileSync, writeFileSync} from "node:fs";
import {dirname, join} from "node:path";
import {execSync} from "node:child_process";

const ROOT = process.cwd();
const VITEST_LCOV = join(ROOT, "coverage", "lcov.info");
const NYC_DIR = join(ROOT, ".nyc_output");
const CYPRESS_LCOV_DIR = join(ROOT, "coverage", "cypress");
const CYPRESS_LCOV = join(CYPRESS_LCOV_DIR, "lcov.info");
const MERGED_LCOV = VITEST_LCOV;

function fail(message) {
    // eslint-disable-next-line no-console
    console.error(`❌ ${message}`);
    process.exit(1);
}

function normalizeLcovPaths(lcovContent) {
    // Normalize SF: paths to forward slashes
    return lcovContent.replace(/^SF:(.*)$/gm, (line, p1) => {
        const normalized = String(p1).replace(/\\/g, "/");
        return `SF:${normalized}`;
    });
}

function splitRecords(lcovContent) {
    // LCOV records are separated by end_of_record
    return lcovContent
        .split("end_of_record")
        .map((r) => r.trim())
        .filter(Boolean)
        .map((r) => `${r}\nend_of_record\n`);
}

function recordKey(record) {
    const match = record.match(/^SF:(.*)$/m);
    return match ? match[1].trim() : `__no_sf__${Math.random()}`;
}

function mergeLcov(vitestContent, cypressContent) {
    const vitestRecords = splitRecords(vitestContent);
    const cypressRecords = splitRecords(cypressContent);

    // Keep latest record per SF (Cypress first, then Vitest as fallback)
    const map = new Map();

    for (const rec of cypressRecords) {
        map.set(recordKey(rec), rec);
    }
    for (const rec of vitestRecords) {
        const key = recordKey(rec);
        if (!map.has(key)) {
            map.set(key, rec);
        }
    }

    return Array.from(map.values()).join("");
}

// 1) Validate Vitest LCOV exists
if (!existsSync(VITEST_LCOV)) {
    fail(`Vitest LCOV not found at ${VITEST_LCOV}. Run "npm run test:coverage" first.`);
}

// 2) Validate Cypress NYC output exists
if (!existsSync(NYC_DIR)) {
    fail(`Cypress NYC output not found at ${NYC_DIR}. Run Cypress with E2E_COVERAGE=true first.`);
}

// 3) Ensure output dir exists
mkdirSync(CYPRESS_LCOV_DIR, {recursive: true});

// 4) Generate Cypress LCOV from NYC output
// We intentionally generate into coverage/cypress to avoid clobbering Vitest coverage.
try {
    execSync(`npx nyc report --reporter=lcov --report-dir="${CYPRESS_LCOV_DIR}"`, {
        stdio: "inherit",
    });
} catch (e) {
    fail("Failed to generate Cypress LCOV via nyc report.");
}

if (!existsSync(CYPRESS_LCOV)) {
    fail(`Cypress LCOV not generated at ${CYPRESS_LCOV}. Check @cypress/code-coverage setup.`);
}

// 5) Read both LCOV files
const vitestRaw = readFileSync(VITEST_LCOV, "utf8");
const cypressRaw = readFileSync(CYPRESS_LCOV, "utf8");

const vitest = normalizeLcovPaths(vitestRaw);
const cypress = normalizeLcovPaths(cypressRaw);

// 6) Merge
const merged = mergeLcov(vitest, cypress);

// 7) Write merged LCOV back to coverage/lcov.info
mkdirSync(dirname(MERGED_LCOV), {recursive: true});
writeFileSync(MERGED_LCOV, merged, "utf8");

// eslint-disable-next-line no-console
console.log("✅ Merged LCOV written to coverage/lcov.info (Vitest + Cypress).");
